Type
----

Type objects represent C types, used for calling native functions in dynamic libraries.

Type() cannot be called directly.  Instead use the properties like Type.int, and the methods like Type.array() and Type['function']()


Type objects representing basic C types are available as properties on Type, with the obvious meanings:

Type.char                    C "char"
Type.double                  C "double"
Type.float                   C "float"
Type.int                     C "int"
Type.int64                   C "int64"
Type.long                    C "long"
Type.long_double             C "long double"
Type.long_long               C "long long"
Type.short                   C "short"
Type.signed_char             C "signed char"
Type.signed_int              C "signed int"
Type.signed_int64            C "signed int64"
Type.signed_long             C "signed long"
Type.signed_long_long        C "signed long long"
Type.signed_short            C "signed short"
Type.unsigned_char           C "unsigned char"
Type.unsigned_int            C "unsigned int"
Type.unsigned_int64          C "unsigned int64"
Type.unsigned_long           C "unsigned long"
Type.unsigned_long_long      C "unsigned long long"
Type.unsigned_short          C "unsigned short"
Type.valist                  C "valist"
Type.void                    C "void"

(Note that you must write Type["void"] rather than Type.void, because "void" is a reserved word in javascript.)

Type objects representing C structs, unions, functions, pointers, and fixed-length arrays are acquired by calling methods on Type.


Type.array(type, length)
------------------------

Creates a new Type object representing a fixed-size array.  The first argument is the Type of array elements, and the second is the number of elements.  Types created with this function have a property named "0" which contains the type of its members.


Type.bitfield(type, length)
---------------------------

Creates a new Type object representing a bitfield.  The first argument is the base integer type and the second is the number of bits.  Types created with this function have a read-only property named "0" which contains the base integer type.


Type.function(returnType, params [, elipsis] [, callConv])
----------------------------------------------------------

Creates a new Type object representing a function.

* returnType: A Type object
* params: Array of Objects containing a Type .type property, an optional String .name property identifying the name of the parameter, and an optional boolean .const (default false)
* elipsis: Can be false (default), true or undefined
* callConv: Can be 'cdecl' (default), 'stdcall' or undefined

Types created with this function have read-only properties with the same names as the parameters, containing the argument objects passed to this function. These  objects are augmented with read-only property "index".  Also, function types have read-only properties named 0 through n, which point to the same objects.  Furthermore, there are "returnType", "callConv" and "elipsis" properties.

You have to write Type['function'] rather than Type.function in javascript code, because "function" is a reserved word.


Pass a zero-length array for "params" to represent a 0-parameter C function (which is written as "int myfunc(void);" in C).

Pass a zero-length array for "params" and |true| for "elipsis" to represent a C function with an undefined paramater list (e.g. "int myfunc();"), which can be called with a variable number of arguments


Type.pointer()
--------------

    t = Type.pointer(direct)

Creates a new Type object representing a pointer. The argument is the Type being pointed to.

Types created with this function have a read-only property named "0" which contains the type it points to.


Type.struct()
-------------

    t = Type.struct(member0, member1, ...)

Creates a new Type object representing a _struct_. The member arguments should be objects containing two properties: _name_ and _type_. The _type_ property should be a Type object.

Types created with this function have read-only properties with the same names as the members, containing the argument objects passed to this function. These objects are augmented with read-only properties _offset_ and _index_. Also, struct types have read-only properties named 0 through _n_, which point to the same objects.


Type.union()
------------

    t = Type.union(member0, member1, ...)

Creates a new Type object representing a _union_. The member arguments should be objects containing two properties: _name_ and _type_. The _type_ property should be a Type object.



Type.prototype
--------------

All the Type objects returned by the properties and methods above extend Type.prototype, and so have the following instance properties and methods:


Type.prototype.callConv
-----------------------

Read-only.  Contains 'cdecl' or 'stdcall' for function types, and |undefined| for other types.


Type.prototype.elipsis
----------------------

Read-only.  Contains |true| or |false| for function types, and |undefined| for other types.


Type.prototype.length
---------------------

Read-only.  Contains the number of arguments for functions, members of structs and unions, and elements of arrays. Undefined for other types.


Type.prototype.setMembers()
---------------------------

    t.setMembers(member0, member1, ...)

Replaces existing members of struct or union types with new members. This function can be used to alter a forward-declaration into a proper declaration, and is needed to make cyclical type references.


Type.prototype.sizeof
---------------------

Read-only.  Contains the size, in bytes, of objects of this type.


Type.prototype.toString()
-------------------------

Returns one of the following strings:

* pointer
* array
* bitfield
* void
* valist
* function
* struct
* union
* char
* short
* int
* long
* long_long
* int64
* signed_char
* signed_short
* signed_int
* signed_long
* signed_long_long
* signed_int64
* unsigned_char
* unsigned_short
* unsigned_int
* unsigned_long
* unsigned_long_long
* unsigned_int64
* float
* double
* long_double
